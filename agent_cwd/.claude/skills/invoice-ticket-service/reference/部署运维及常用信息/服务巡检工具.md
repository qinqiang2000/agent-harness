| **文档编号** | **适用产品版本** | **使用范围** | **更新内容** | **创建（修改）时间** | **责任人** |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **v25.0.01** | **7.0及以上** | **公开** | **创建** | **2025-09-28** | **欧浩斌** |


# 文档说明
本文档适用于服务器日常巡检使用，巡检内容包括服务器资源使用情况（cpu、内存、磁盘），基本服务状态检测（ssh、firewalld）等。文档兼容大多数操作系统，但部分命令可能系统并不自带安装，脚本执行可能会报错，首次执行，建议再手动检测，对照输出内容是否准确。

# 工具包操作手册
工具使用shell语言编写，可以在服务器上创建一个 inspection.sh 文件，然后复制 2 中的 代码内容到文件中即可，或通过下载工具包使用。

工具下载地址：

url： [http://dl.piaozone.com:18025/download/tools/monitor-tool.tar.gz](http://dl.piaozone.com:18025/download/tools/monitor-tool.tar.gz)

账号密码：fpy   Fpy@piaonzone2025#$ 

工具操作手册：

```shell
#首次使用时，需要先解压工具包
cd /opt
tar xf monitor-tool.tar.gz
cd monitor

sh inspection.sh
```

输出示例：

![](https://cdn.nlark.com/yuque/0/2025/png/21778712/1759044499199-0b711621-2285-4da2-9675-ad6334221cb5.png)

# 工具代码内容
```shell
#!/bin/bash

script_path=$(cd `dirname $0`;pwd)
file_path=$script_path/log/inspection_`date +%Y%m%d%H%M%S`.log
#判断log目录是否存在，不存在则创建
if [ -d $script_path/log ];then
	#判断log目录下是否存在文件，存在则mv到/tmp/bak/中
	if [ `ls -l  $script_path/log/|wc -l ` != 0 ];then
		#判断/tmp/bak/目录是否存在，不存在则创建
		if [ -d /tmp/bak/ ];then
			mv $script_path/log/* /tmp/bak/
		else
			mkdir -p /tmp/bak/
			mv $script_path/log/* /tmp/bak/
		fi

	fi
else
	mkdir -p $script_path/log
fi
#固定格式
check_set() {
        echo "==================================================" >> $file_path
}

check_title() {
        echo "############## $@ ################" >> $file_path
}

check_head() {
        check_set
        check_title $@
        check_set
}

check_tail() {
        #echo  >> $file_path
        echo  >> $file_path
}

#服务器信息输出
server_info(){
        check_head "服务器信息"
        server_ip=`hostname -I |awk '{print $1}'`
        echo "本机ip： $server_ip" >> $file_path
		echo "巡检时间：`date +%Y-%m-%d-%H:%M` " >> $file_path
        check_tail

}

#cpu检查
check_cpu() {
        check_head "cpu 检查"
        cpu_5m=`uptime |awk -F 'average:' '{print $2}'|awk -F ',' '{print $1}'`
        cpu_10m=`uptime |awk -F 'average:' '{print $2}'|awk -F ',' '{print $2}'`
        cpu_15m=`uptime |awk -F 'average:' '{print $2}'|awk -F ',' '{print $3}'`
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')
        nproc=`nproc`
        cpu_warn=`echo "$nproc * 0.9" |bc`
        echo "cpu 核心数：$nproc" >> $file_path
        echo "cpu 使用率： ${cpu_usage}%" >>$file_path
        echo "cpu 5分钟平均负载：$cpu_5m" >> $file_path
		        echo "cpu 10分钟平均负载：$cpu_10m" >> $file_path
        echo "cpu 15分钟平均负载：$cpu_15m" >> $file_path
            # 判断状态
    if (( $(echo "$cpu_usage > 90" | bc -l) )); then
        echo -e "\e[31m [ok] \e[0m cpu使用率过高：${cpu_usage}%" >> $file_path
    elif (( $(echo "$cpu_usage > 80" | bc -l) )); then
        echo -e "\e[33m [ok] \e[0m cpu使用率偏高：${cpu_usage}%" >> $file_path
    else
        echo -e "\e[32m [ok] \e[0m cpu使用率正常：${cpu_usage}%" >> $file_path
    fi
        check_tail
}

#内存检查
check_mem() {
        check_head "内存检查"
        mem_total=`free -m |grep Mem|awk '{print $2}'`
        mem_use=`free -m |grep Mem|awk '{print $3}'`
        mem_free=`free -m |grep Mem|awk '{print $4}'`
        mem_usage_per=$(echo "scale=2; ${mem_use}*100/$mem_total" | bc)
        echo -e "总内存(M)：\e[33m $mem_total\e[0m" >> $file_path
        echo -e "已用内存(M)：\e[32m $mem_use\e[0m" >> $file_path
        if (( `echo "$mem_usage_per > 90" | bc -l` ))
        then
                echo -e "\e[31m [warning] \e[0m 内存使用率偏高" >> $file_path 
        else
                echo -e "\e[32m [ok] \e[0m 内存使用率正常：${mem_usage_per}%" >> $file_path
        fi

        check_tail
}

#磁盘检查
check_disk() {
        check_head "磁盘检查"
        echo -e "检测到服务器有\e[32m `df -h |grep -v "docker-data"|grep "^/"|wc -l` \e[0m个挂载点" >> $file_path
        echo "具体信息如下：" >> $file_path
        df -h |grep -v "docker-data"|grep "^/"|awk '{print "磁盘名称：" $1 "\t"  "磁盘空间：" $2 "\t" "可用空间：" $4 "\t" "已用百分比："  $5 "\t" "挂载点：" $6}' >> $file_path
            # 检查使用率超过90%的分区
    HIGH_USAGE=$(df -h | awk 'NR>1 {gsub("%","",$5); if($5>90) print $6 " (" $5 "%)"}')
    if [ -n "$HIGH_USAGE" ]; then
        echo -e  "\e[31m [ERROR] \e[0m以下分区使用率超过90%: $HIGH_USAGE" >> $file_path
    else
        echo -e  "\e[32m [OK] \e[0m 所有分区使用率正常" >> $file_path
    fi
        check_tail
}

#服务检查
check_service() {
        check_head "服务检查"
        for i in $service_list
        do
                if [ -f /usr/lib/systemd/system/${i}.service ]

                then
                        echo -e "检查到服务器上存在\e[35m $i \e[0m启动脚本" >> $file_path
                        if [ `systemctl status $i |grep Active |grep dead|wc -l` == 1 ]
                        then
                                echo -e "$i 的服务状态：\e[31m`systemctl status $i |grep Active |awk '{print $2 $3}'`\e[0m" >> $file_path
                        elif [ `systemctl status $i |grep Active |grep running|wc -l` == 1 ]
                        then
                                echo -e "$i 的服务状态：\e[32m`systemctl status $i |grep Active |awk '{print $2 $3}'`\e[0m" >> $file_path
                        else
                                echo -e "$i 的服务状态：\e[38m`systemctl status $i |grep Active |awk '{print $2 $3}'`\e[0m" >> $file_path
                        fi

                        check_tail
        #       else
        #               echo "未检查到 $i 的启动脚本" >> $file_path
        #               check_tail
                fi
        done
#minio检查
        if [ `ps -ef |grep minio|grep -v grep |wc -l` != 0 ]
        then 
                echo "检测到服务器上存在minio进程，具体如下：" >> $file_path
                ps -ef |grep minio|grep -v grep >> $file_path
                check_tail
        #else
                #echo "未检测到minio进程"
                #check_tail
        fi

#nginx检查
        if [ `ps -ef |grep nginx|grep -v grep |wc -l` != 0 ] && [ `netstat -anpt | grep nginx|wc -l` != 0 ]
        then
                echo "检查到存在nginx进程！" >> $file_path
                echo -e "nginx监听端口：\e[32m `netstat -anpt | grep nginx|grep LISTEN |awk '{print $4}'|awk -F ':' '{printf $2 "\t"}'` \e[0m" >> $file_path
                check_tail
        #else
        #        echo "未检测到nginx进程"
        #       check_tail
        fi
		

}
#容器状态
container_check(){
        which kubectl &>/dev/null
        [ $? != 0 ];return
        check_head "容器状态检查"
        container_ns=`kubectl get pods -A | grep mservice|head|awk '{print $1}'`
        kubectl get pods -n $container_ns >> $file_path
        check_num=`kubectl get pods -n $container_ns |awk 'NR>1{print $2}'|uniq|wc -l`
        if [ $check_num == 1 ];then
            echo -e "\e[32m [ok] \e[0m容器状态正常" >> $file_path
		else
			echo -e "\e[31m [error] \e[0m有容器状态不正常，请检查" >> $file_path
        fi
        check_tail


}
#db检查
check_db(){
        check_head "数据库检查"
        if [ `netstat -anpt | grep ":::5432"|wc -l` != 0 ];then
                echo "检测到pgsql进程" >> $file_path
                pgsql_role=`systemctl status postgresql | grep walsender|wc -l`
                if [ $pgsql_role != 0 ];then
                        echo "本机pgsql为主，主从复制状态：
                        `su - postgres -c "psql -c 'select state from pg_stat_replication;'"`" >>  $file_path
                else
                        echo "本机pgsql为从，主从复制状态：
                        `su - postgres -c "psql -c 'select status from pg_stat_wal_receiver;'"`">> $file_path
                fi
        fi
        check_tail
}
#服务列表
service_list="firewalld
                sshd
                zookeeper
                redis
                redis-6379
                redis-6380
                redis-6381
                rabbitmq-server
                es
                logstash
                kafka"
				
main() {
#cpu、mem、dis检查
        server_info
        check_cpu
        check_mem
        check_disk
#应用服务器检查
        check_service
#k8s容器检查
        #container_check
#db检查
        #check_db
		echo "巡检完成，请查看巡检日志： $file_path"
}

main
```

















